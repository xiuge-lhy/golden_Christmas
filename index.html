<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8">
    <title>流金星尘-立体星顶版</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; font-family: 'STHeiti', sans-serif; }
        #input_video { 
            position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; 
            object-fit: cover; z-index: -1; transform: scaleX(-1); 
        }
        #info { position: absolute; top: 40px; width: 100%; text-align: center; color: #ffd700; letter-spacing: 5px; z-index: 10; font-weight: 300; text-shadow: 0 0 15px rgba(0,0,0,0.8); pointer-events: none; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ffd700; font-size: 14px; }
    </style>
</head>
<body>
    <div id="info">GOLDEN CHRISTMAS TO XUEQIN<br><span style="font-size: 11px; opacity: 0.8; letter-spacing: 2px;">AR 增强现实 | 立体树顶星</span></div>
    <div id="loading">正在点亮树顶星...</div>
    <video id="input_video" autoplay playsinline></video>

    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://fastly.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);
        
        camera.position.set(0, 1.2, 24); 
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));

        function createSuperGlow(isSnow = false) {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 128;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            if (isSnow) {
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
                grad.addColorStop(0.2, 'rgba(200, 230, 255, 1)'); 
                grad.addColorStop(0.6, 'rgba(100, 150, 255, 0.2)'); 
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            } else {
                grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); 
                grad.addColorStop(0.1, 'rgba(255, 220, 50, 1)'); 
                grad.addColorStop(0.4, 'rgba(255, 160, 0, 0.6)'); 
                grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            }
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 128, 128);
            return new THREE.CanvasTexture(canvas);
        }

        const treeMat = new THREE.PointsMaterial({ 
            size: 0.2, map: createSuperGlow(false), transparent: true, 
            blending: THREE.AdditiveBlending, depthWrite: false, opacity: 1.0
        });

        // 1. 圣诞树主体
        const particleCount = 30000;
        const treeGeo = new THREE.BufferGeometry();
        const treePos = new Float32Array(particleCount * 3), scatPos = new Float32Array(particleCount * 3);
        for (let i = 0; i < particleCount; i++) {
            const h = Math.random() * 8; const r = Math.sqrt(Math.random()) * (8 - h) * 0.32; const a = Math.random() * Math.PI * 2;
            treePos[i*3] = Math.cos(a)*r; treePos[i*3+1] = h - 4; treePos[i*3+2] = Math.sin(a)*r;
            const sd = 7.0 + Math.random() * 9.0; const p = Math.random() * Math.PI * 2, t = Math.random() * Math.PI;
            scatPos[i*3] = sd * Math.sin(t) * Math.cos(p); scatPos[i*3+1] = sd * Math.sin(t) * Math.sin(p); scatPos[i*3+2] = sd * Math.cos(t);
        }
        treeGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(treePos), 3));
        const treePoints = new THREE.Points(treeGeo, treeMat);
        scene.add(treePoints);

        // 2. 树顶星 (立体五角星形状修改)
        const starCount = 1500;
        const starGeo = new THREE.BufferGeometry();
        const starPos = new Float32Array(starCount * 3), starScatPos = new Float32Array(starCount * 3);
        for (let i = 0; i < starCount; i++) {
            const starPointsCount = 5;
            const outerR = 0.55;
            const innerR = 0.22;
            const angleStep = Math.PI / starPointsCount;
            
            // 决定当前点属于哪一个角
            const section = Math.floor(Math.random() * starPointsCount * 2);
            const r = (section % 2 === 0) ? outerR : innerR;
            const baseAngle = section * angleStep;
            
            // 在角与角之间进行随机插值，使星星变“实心”
            const t_rand = Math.random();
            const finalR = r * Math.sqrt(Math.random()); // 使用平方根分布让边缘粒子更密集
            const finalAngle = baseAngle + (Math.random() - 0.5) * 0.2;

            starPos[i*3] = Math.cos(finalAngle) * finalR;
            starPos[i*3+1] = Math.sin(finalAngle) * finalR + 4.2;
            starPos[i*3+2] = (Math.random() - 0.5) * 0.25; // 增加厚度感

            const sd = 8.0 + Math.random() * 5.0; 
            const p = Math.random() * Math.PI * 2, t = Math.random() * Math.PI;
            starScatPos[i*3] = sd * Math.sin(t) * Math.cos(p); 
            starScatPos[i*3+1] = sd * Math.sin(t) * Math.sin(p) + 3.0; 
            starScatPos[i*3+2] = sd * Math.cos(t);
        }
        starGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(starPos), 3));
        const starPointsMesh = new THREE.Points(starGeo, treeMat);
        scene.add(starPointsMesh);

        // 3. 雪花
        const snowCount = 2000; 
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = new Float32Array(snowCount * 3), snowVel = new Float32Array(snowCount); 
        for (let i = 0; i < snowCount; i++) {
            snowPos[i*3] = (Math.random() - 0.5) * 50; snowPos[i*3+1] = Math.random() * 30 - 15; snowPos[i*3+2] = (Math.random() - 0.5) * 30;
            snowVel[i] = 0.02 + Math.random() * 0.04; 
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({
            size: 0.35, map: createSuperGlow(true), transparent: true, opacity: 1.0, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const snowPoints = new THREE.Points(snowGeo, snowMat);
        scene.add(snowPoints);

        // 手势与动画逻辑 (保持原有功能并适配新变量)
        let morph = 0, target = 0, targetRotY = 0, currRotY = 0, targetRotX = 0, currRotX = 0, isHandDetected = false;
        const hands = new Hands({locateFile: (file) => `https://fastly.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.6, minTrackingConfidence: 0.6 });
        
        hands.onResults(res => {
            document.getElementById('loading').style.display = 'none';
            if (res.multiHandLandmarks && res.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const lm = res.multiHandLandmarks[0];
                const palmBase = Math.sqrt(Math.pow(lm[9].x - lm[0].x, 2) + Math.pow(lm[9].y - lm[0].y, 2));
                let extendedCount = 0;
                [8, 12, 16, 20].forEach(tip => {
                    const dist = Math.sqrt(Math.pow(lm[tip].x - lm[0].x, 2) + Math.pow(lm[tip].y - lm[0].y, 2));
                    if (dist > palmBase * 1.6) extendedCount++;
                });
                target = extendedCount >= 2 ? 1 : 0;
                targetRotY = -(0.5 - lm[0].x) * Math.PI * 4; 
                targetRotX = (lm[0].y - 0.5) * Math.PI * 0.8; 
            } else { isHandDetected = false; target = 0; }
        });

        new Camera(document.getElementById('input_video'), {
            onFrame: async () => { await hands.send({image: document.getElementById('input_video')}); },
            width: 1280, height: 720
        }).start();

        function animate() {
            requestAnimationFrame(animate);
            const time = Date.now() * 0.001;
            if (!isHandDetected) { targetRotY += 0.006; targetRotX = Math.sin(time) * 0.05; }
            morph += (target - morph) * 0.04; 
            const t = 1 - Math.pow(1 - morph, 2); 

            treeMat.size = 0.18 + (t * 0.17) + Math.sin(time * 3) * 0.02;
            currRotY += (targetRotY - currRotY) * 0.05;
            currRotX += (targetRotX - currRotX) * 0.05;

            [treePoints, starPointsMesh].forEach(p => {
                p.rotation.y = currRotY;
                p.rotation.x = currRotX;
                p.position.y = -1.5; 
            });

            // 更新树身
            const treeArr = treeGeo.attributes.position.array;
            for (let i = 0; i < particleCount; i++) {
                treeArr[i*3] = treePos[i*3] * (1-t) + scatPos[i*3] * t;
                treeArr[i*3+1] = treePos[i*3+1] * (1-t) + scatPos[i*3+1] * t;
                treeArr[i*3+2] = treePos[i*3+2] * (1-t) + scatPos[i*3+2] * t;
            }
            treeGeo.attributes.position.needsUpdate = true;

            // 更新树顶立体星
            const starArr = starGeo.attributes.position.array;
            for (let i = 0; i < starCount; i++) {
                starArr[i*3] = starPos[i*3] * (1-t) + starScatPos[i*3] * t;
                starArr[i*3+1] = starPos[i*3+1] * (1-t) + starScatPos[i*3+1] * t;
                starArr[i*3+2] = starPos[i*3+2] * (1-t) + starScatPos[i*3+2] * t;
            }
            starGeo.attributes.position.needsUpdate = true;

            // 更新雪花
            const snowArr = snowGeo.attributes.position.array;
            for (let i = 0; i < snowCount; i++) {
                snowArr[i*3+1] -= snowVel[i]; 
                if (snowArr[i*3+1] < -15) snowArr[i*3+1] = 15;
            }
            snowGeo.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>